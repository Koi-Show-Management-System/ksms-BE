name: Optimized CI/CD Pipeline - Build on VPS with Cache

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  trigger-vps-build:
    name: Build and Deploy on VPS
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Add timeout to prevent hanging jobs
    
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add host to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
        
    - name: Verify SSH Connection
      run: |
        if ! ssh -q ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "exit"; then
          echo "❌ SSH connection failed. Please check your SSH credentials."
          exit 1
        else
          echo "✅ SSH connection successful."
        fi
        
    - name: Create Build Script with NuGet Cache
      run: |
        cat > build-with-cache.sh << 'EOL'
#!/bin/bash
set -e

# ==== CONFIGURATION ====
NUGET_CACHE_DIR="/opt/nuget-cache"
NUGET_MAX_CACHE_SIZE="5G"
MAX_CACHE_AGE="30"
APP_NAME="ksms-api"
BUILD_LOG_DIR="$HOME/build-agent/logs"

# ==== SETUP NUGET CACHE ENVIRONMENT ====
setup_nuget_cache() {
  echo "Setting up NuGet package cache..."
  
  # Create cache directory if it doesn't exist
  if [ ! -d "$NUGET_CACHE_DIR" ]; then
    echo "Creating NuGet cache directory at $NUGET_CACHE_DIR"
    sudo mkdir -p "$NUGET_CACHE_DIR"
    sudo chown -R $(whoami):$(whoami) "$NUGET_CACHE_DIR"
    chmod -R 755 "$NUGET_CACHE_DIR"
  fi
  
  # Create global packages directory under cache dir
  mkdir -p "$NUGET_CACHE_DIR/global-packages"
  mkdir -p "$NUGET_CACHE_DIR/http-cache"
  mkdir -p "$NUGET_CACHE_DIR/temp"
  
  # Configure NuGet to use cache
  export NUGET_PACKAGES="$NUGET_CACHE_DIR/global-packages"
  export NUGET_HTTP_CACHE_PATH="$NUGET_CACHE_DIR/http-cache"
  export NUGET_PLUGINS_CACHE_PATH="$NUGET_CACHE_DIR/temp"
  
  # Create or update NuGet.Config if needed
  NUGET_CONFIG_DIR="$HOME/.nuget/NuGet"
  mkdir -p "$NUGET_CONFIG_DIR"
  
  if [ ! -f "$NUGET_CONFIG_DIR/NuGet.Config" ]; then
    cat > "$NUGET_CONFIG_DIR/NuGet.Config" << EOF
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <config>
    <add key="globalPackagesFolder" value="$NUGET_CACHE_DIR/global-packages" />
    <add key="repositoryPath" value="$NUGET_CACHE_DIR/global-packages" />
    <add key="http_cache_path" value="$NUGET_CACHE_DIR/http-cache" />
    <add key="defaultPushSource" value="https://api.nuget.org/v3/index.json" />
  </config>
  <packageSources>
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
  </packageSources>
</configuration>
EOF
  fi
  
  echo "NuGet cache configured at $NUGET_CACHE_DIR"
}

# ==== MAINTAIN CACHE ====
maintain_nuget_cache() {
  echo "Performing NuGet cache maintenance..."
  
  # Check cache size
  CACHE_SIZE=$(du -sh "$NUGET_CACHE_DIR" | cut -f1)
  echo "Current cache size: $CACHE_SIZE"
  
  # Delete temp files in cache
  find "$NUGET_CACHE_DIR/temp" -type f -mtime +1 -delete 2>/dev/null || true
  
  # Delete old packages in http cache to ensure getting new versions
  find "$NUGET_CACHE_DIR/http-cache" -type f -mtime +$MAX_CACHE_AGE -delete 2>/dev/null || true
  
  # Check if cache exceeds maximum size
  if command -v numfmt >/dev/null 2>&1; then
    CACHE_SIZE_BYTES=$(du -s "$NUGET_CACHE_DIR" | cut -f1)
    MAX_SIZE_BYTES=$(numfmt --from=iec $NUGET_MAX_CACHE_SIZE)
    
    if [ $CACHE_SIZE_BYTES -gt $MAX_SIZE_BYTES ]; then
      echo "Cache exceeds maximum size. Pruning oldest packages..."
      
      # Find and delete oldest package directories
      find "$NUGET_CACHE_DIR/global-packages" -mindepth 2 -maxdepth 2 -type d | \
        xargs -I {} bash -c 'echo "$(find "{}" -type f -printf "%T@ %p\n" | sort -n | head -1 | cut -d" " -f1) {}"' | \
        sort -n | head -n 100 | cut -d" " -f2- | xargs rm -rf
        
      CACHE_SIZE=$(du -sh "$NUGET_CACHE_DIR" | cut -f1)
      echo "Cache size after pruning: $CACHE_SIZE"
    fi
  else
    echo "numfmt command not found, skipping size-based cache pruning"
  fi
}

# ==== SETUP BUILD ENVIRONMENT ====
setup_build_env() {
  echo "Setting up build environment..."
  
  # Install .NET SDK if not present
  if ! command -v dotnet &> /dev/null; then
    echo "Installing .NET SDK..."
    wget https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
    sudo dpkg -i packages-microsoft-prod.deb
    sudo apt-get update
    sudo apt-get install -y dotnet-sdk-8.0
  else
    echo ".NET SDK already installed, checking version..."
    dotnet --version
  fi
  
  # Create build directories
  mkdir -p ~/build-agent/{source,artifacts,logs}
  
  # Setup NuGet cache
  setup_nuget_cache
}

# ==== CLONE REPOSITORY ====
clone_repo() {
  echo "Cloning repository..."
  cd ~/build-agent/source
  
  # Clean previous build if exists
  rm -rf ./app
  
  # Clone the repository with terminal feedback
  git clone $REPO_URL ./app
  
  # Exit if clone failed
  if [ ! -d "./app" ]; then
    echo "❌ Failed to clone repository."
    exit 1
  fi
  
  cd ./app
  
  # Check if branch exists
  if ! git branch -a | grep -q "$BRANCH_NAME"; then
    echo "❌ Branch '$BRANCH_NAME' not found in repository."
    git branch -a
    exit 1
  fi
  
  # Checkout specified branch
  git checkout $BRANCH_NAME
  
  echo "✅ Repository cloned and branch '$BRANCH_NAME' checked out."
}

# ==== BUILD APPLICATION WITH CACHE ====
build_app() {
  echo "Building application using NuGet cache..."
  cd ~/build-agent/source/app
  
  # Create log directory if it doesn't exist
  mkdir -p $BUILD_LOG_DIR
  
  # Configure environment for this build
  export NUGET_PACKAGES="$NUGET_CACHE_DIR/global-packages"
  export NUGET_HTTP_CACHE_PATH="$NUGET_CACHE_DIR/http-cache"
  export NUGET_PLUGINS_CACHE_PATH="$NUGET_CACHE_DIR/temp"
  
  # Log cache state before build
  echo "Before build - NuGet cache status:"
  du -sh $NUGET_CACHE_DIR/global-packages
  
  # Restore dependencies with caching enabled
  echo "Restoring dependencies (using cache)..."
  time dotnet restore --interactive:false | tee $BUILD_LOG_DIR/restore.log
  
  # Build the application
  echo "Building application..."
  time dotnet build --configuration Release --no-restore | tee $BUILD_LOG_DIR/build.log
  
  # Run tests if there are any
  if find . -name "*.Tests.csproj" -o -name "*Tests.csproj" | grep -q .; then
    echo "Running tests..."
    time dotnet test --no-build --verbosity normal --configuration Release | tee $BUILD_LOG_DIR/test.log
  else
    echo "No test projects found, skipping tests"
  fi
  
  # Publish the application - framework dependent to reduce size
  echo "Publishing application..."
  time dotnet publish --configuration Release --runtime linux-x64 --self-contained false -p:PublishSingleFile=false --output ~/build-agent/artifacts/app | tee $BUILD_LOG_DIR/publish.log
  
  # Check if build succeeded
  if [ ! -d ~/build-agent/artifacts/app ]; then
    echo "❌ Build failed. Check logs for details."
    exit 1
  fi
  
  # Log cache state after build
  echo "After build - NuGet cache status:"
  du -sh $NUGET_CACHE_DIR/global-packages
  
  # Maintain cache after build
  maintain_nuget_cache
  
  echo "✅ Build completed successfully."
}

# ==== HANDLE IDENTITY MODEL DLLS ====
handle_identity_dlls() {
  # Check if we need identity DLLs (searching in project files)
  if grep -q "Microsoft.IdentityModel" ~/build-agent/source/app/*.csproj 2>/dev/null; then
    echo "Project uses Identity Model. Setting up DLLs..."
    
    mkdir -p ~/build-agent/identity-dlls
    cd ~/build-agent/identity-dlls
    
    # Download and extract only if needed
    if [ ! -f Microsoft.IdentityModel.Tokens.dll ]; then
      echo "Downloading Identity Model packages..."
      
      # Create an array of packages to download
      PACKAGES=(
        "Microsoft.IdentityModel.Protocols/8.2.1"
        "Microsoft.IdentityModel.Logging/8.2.1"
        "Microsoft.IdentityModel.Tokens/8.2.1"
        "Microsoft.IdentityModel.JsonWebTokens/8.2.1"
        "Microsoft.IdentityModel.Protocols.OpenIdConnect/8.2.1"
        "System.IdentityModel.Tokens.Jwt/8.2.1"
      )
      
      # Download packages in parallel using background processes
      for pkg_spec in "${PACKAGES[@]}"; do
        pkg_name=$(echo $pkg_spec | cut -d/ -f1)
        pkg_version=$(echo $pkg_spec | cut -d/ -f2)
        pkg_short=$(echo $pkg_name | cut -d. -f3 | tr '[:upper:]' '[:lower:]')
        
        echo "Downloading $pkg_name v$pkg_version..."
        wget -q "https://www.nuget.org/api/v2/package/$pkg_name/$pkg_version" -O "./$pkg_short.nupkg" &
      done
      
      # Wait for all downloads to complete
      wait
      
      # Extract DLLs
      for pkg_short in protocols logging tokens jwt openidconnect systemjwt; do
        if [ -f "./$pkg_short.nupkg" ]; then
          mkdir -p "./tmp-$pkg_short"
          unzip -q "./$pkg_short.nupkg" -d "./tmp-$pkg_short"
          cp "./tmp-$pkg_short/lib/net8.0/"*.dll ./ 2>/dev/null || true
          rm -rf "./tmp-$pkg_short"
          rm "./$pkg_short.nupkg"
        else
          echo "Warning: Package $pkg_short was not downloaded successfully."
        fi
      done
    else
      echo "Identity DLLs already exist, reusing..."
    fi
    
    # Copy to deployment location
    APP_PATH="/var/www/$APP_NAME"
    
    sudo mkdir -p "$APP_PATH/shared/identity-libs"
    sudo cp -v ./*.dll "$APP_PATH/shared/identity-libs/" 2>/dev/null || true
    sudo cp -v ./*.dll "$APP_PATH/current/" 2>/dev/null || true
    sudo chown -R www-data:www-data "$APP_PATH/shared/identity-libs" "$APP_PATH/current"
    
    echo "✅ Identity DLLs set up successfully."
  else
    echo "Project does not use Identity Model. Skipping DLL setup."
  fi
}

# ==== DEPLOY APPLICATION ====
deploy_app() {
  echo "Deploying application..."
  
  # Create necessary directories
  APP_PATH="/var/www/$APP_NAME"
  
  sudo mkdir -p $APP_PATH/{releases,shared/logs}
  
  # Create timestamp for release
  TIMESTAMP=$(date +%Y%m%d%H%M%S)
  RELEASE_PATH="$APP_PATH/releases/$TIMESTAMP"
  
  sudo mkdir -p $RELEASE_PATH
  
  # Copy files to release directory
  sudo cp -R ~/build-agent/artifacts/app/* $RELEASE_PATH/
  
  # Update symlink
  sudo ln -sfn $RELEASE_PATH $APP_PATH/current
  
  # Set permissions
  sudo chown -R www-data:www-data $APP_PATH
  
  # Find main DLL
  DLL_FILE=$(find $RELEASE_PATH -name "$APP_NAME.dll" 2>/dev/null || find $RELEASE_PATH -name "*.API.dll" 2>/dev/null || find $RELEASE_PATH -name "*.dll" | grep -v Microsoft | head -1)
  if [ -z "$DLL_FILE" ]; then
      echo "❌ ERROR: Cannot find main DLL file. Deployment failed."
      exit 1
  fi
  DLL_NAME=$(basename $DLL_FILE)
  DLL_DIR=$(dirname $DLL_FILE)
  
  echo "Found main application DLL: $DLL_NAME"
  
  # Update supervisor config - only if necessary
  if [ ! -f /etc/supervisor/conf.d/$APP_NAME.conf ] || ! grep -q "$DLL_NAME" /etc/supervisor/conf.d/$APP_NAME.conf; then
    echo "Updating supervisor configuration..."
    sudo bash -c "cat > /etc/supervisor/conf.d/$APP_NAME.conf << EOF
[program:$APP_NAME]
command=dotnet $DLL_FILE
directory=$DLL_DIR
autostart=true
autorestart=true
stderr_logfile=/var/log/$APP_NAME/$APP_NAME.err.log
stdout_logfile=/var/log/$APP_NAME/$APP_NAME.out.log
environment=ASPNETCORE_ENVIRONMENT=Production,ASPNETCORE_URLS=\"http://localhost:5000\"
user=www-data
stopsignal=INT
EOF"
    
    sudo mkdir -p /var/log/$APP_NAME
    sudo chown -R www-data:www-data /var/log/$APP_NAME
  fi
  
  # Update Nginx config - only if necessary
  if [ ! -f /etc/nginx/sites-available/$APP_NAME ]; then
    echo "Creating Nginx configuration..."
    sudo bash -c "cat > /etc/nginx/sites-available/$APP_NAME << EOF
server {
    listen 80;
    server_name api.ksms.news;

    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host \\\$host;
        proxy_cache_bypass \\\$http_upgrade;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\\$scheme;
        proxy_set_header X-Real-IP \\\$remote_addr;
        
        # Buffer settings for Swagger
        proxy_buffers 16 16k;
        proxy_buffer_size 16k;
        proxy_read_timeout 300s;
        proxy_connect_timeout 300s;
    }
}
EOF"
    
    # Enable site if needed
    sudo ln -sf /etc/nginx/sites-available/$APP_NAME /etc/nginx/sites-enabled/
    sudo rm -f /etc/nginx/sites-enabled/default
  fi
  
  # Check Nginx configuration
  echo "Validating Nginx configuration..."
  sudo nginx -t
  
  # Restart services
  echo "Restarting services..."
  sudo supervisorctl reread
  sudo supervisorctl update
  sudo supervisorctl restart $APP_NAME
  sudo systemctl reload nginx
  
  # Cleanup - keep 3 latest releases
  echo "Cleaning up old releases..."
  cd $APP_PATH/releases && ls -t | tail -n +4 | sudo xargs -I {} rm -rf {} 2>/dev/null || true
  
  # Clean build artifacts to save space
  echo "Cleaning build artifacts..."
  rm -rf ~/build-agent/artifacts/*
  
  echo "✅ Deployment completed successfully!"
}

# ==== MAIN EXECUTION ====
main() {
  REPO_URL="${1:-https://github.com/yourusername/yourrepo.git}"
  BRANCH_NAME="${2:-main}"
  DEPLOY="${3:-true}"
  
  echo "==== Starting VPS Build Process with NuGet Caching ===="
  echo "Repository: $REPO_URL"
  echo "Branch: $BRANCH_NAME"
  echo "Will deploy: $DEPLOY"
  echo "Using NuGet cache: $NUGET_CACHE_DIR"
  
  setup_build_env
  clone_repo
  build_app
  
  if [ "$DEPLOY" == "true" ]; then
    handle_identity_dlls
    deploy_app
    echo "==== Deployment Completed Successfully! ===="
  else
    echo "==== Build Completed Successfully (No Deployment) ===="
  fi
  
  # Print summary
  echo ""
  echo "==== Build and Deployment Summary ===="
  echo "✅ Build environment: Setup complete"
  echo "✅ Repository: Cloned successfully"
  echo "✅ Branch: $BRANCH_NAME checked out"
  echo "✅ Build: Completed"
  
  if [ "$DEPLOY" == "true" ]; then
    echo "✅ Deployment: Completed"
    echo "✅ Application URL: http://api.ksms.news"
  else
    echo "ℹ️ Deployment: Skipped as requested"
  fi
  
  echo ""
  echo "Cache information:"
  du -sh $NUGET_CACHE_DIR
  echo ""
}

# Run main function with arguments
main "$@"
EOL
        
        chmod +x build-with-cache.sh
        
    - name: Copy and Execute Build Script on VPS
      run: |
        # Determine if we should deploy
        DEPLOY="false"
        if [[ "${{ github.event_name }}" == "push" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          DEPLOY="true"
        fi
        
        # Upload script to VPS
        scp build-with-cache.sh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/build-with-cache.sh
        
        # Execute remote build on VPS with cache
        ssh -o ConnectTimeout=10 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "bash ~/build-with-cache.sh '${{ github.server_url }}/${{ github.repository }}.git' '${{ github.ref_name }}' '$DEPLOY'"
        
    - name: Report Completion
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "✅ CI/CD Pipeline completed successfully!"
        else
          echo "❌ CI/CD Pipeline failed. Check the logs for details."
          exit 1
        fi
