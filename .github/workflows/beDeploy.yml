name: Optimized CI/CD Pipeline - Build on VPS with Cache

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  trigger-vps-build:
    name: Build and Deploy on VPS
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Add timeout to prevent hanging jobs

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for proper versioning

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add host to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

    - name: Verify SSH Connection
      run: |
        if ! ssh -q -o BatchMode=yes ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "exit"; then
          echo "❌ SSH connection failed. Please check your SSH credentials."
          exit 1
        else
          echo "✅ SSH connection successful."
        fi

    - name: Create Build Script with NuGet Cache
      run: |
        cat > build-with-cache.sh << 'EOLSCRIPT'
        #!/bin/bash
        set -e  # Exit immediately if a command exits with a non-zero status
        
        # ==== CONFIGURATION ====
        NUGET_CACHE_DIR="/opt/nuget-cache"
        NUGET_MAX_CACHE_SIZE="5G"
        MAX_CACHE_AGE="30"  # Days
        APP_NAME="ksms-api"
        BUILD_LOG_DIR="$HOME/build-agent/logs"  # Use $HOME, not literal ~
        REPO_URL="${1}"
        BRANCH_NAME="${2}"
        DEPLOY="${3}"
        
        # ==== SETUP NUGET CACHE ENVIRONMENT ====
        setup_nuget_cache() {
          echo "Setting up NuGet package cache..."
        
          # Create cache directory if it doesn't exist (robust permissions handling)
          if [ ! -d "$NUGET_CACHE_DIR" ]; then
            echo "Creating NuGet cache directory at $NUGET_CACHE_DIR"
            sudo mkdir -p "$NUGET_CACHE_DIR"
            sudo chown -R "$(whoami):$(whoami)" "$NUGET_CACHE_DIR"
            sudo chmod -R 755 "$NUGET_CACHE_DIR"
          fi
        
          # Create global packages directory under cache dir
          mkdir -p "$NUGET_CACHE_DIR/global-packages"
          mkdir -p "$NUGET_CACHE_DIR/http-cache"
          mkdir -p "$NUGET_CACHE_DIR/temp"
        
          # Configure NuGet to use cache (environment variables)
          export NUGET_PACKAGES="$NUGET_CACHE_DIR/global-packages"
          export NUGET_HTTP_CACHE_PATH="$NUGET_CACHE_DIR/http-cache"
          export NUGET_PLUGINS_CACHE_PATH="$NUGET_CACHE_DIR/temp"
        
          # Create or update NuGet.Config (more robust XML handling)
          NUGET_CONFIG_DIR="$HOME/.nuget/NuGet"  # Use $HOME
          mkdir -p "$NUGET_CONFIG_DIR"
        
          if [ ! -f "$NUGET_CONFIG_DIR/NuGet.Config" ]; then
            echo "Creating NuGet.Config..."
            # Using xmlstarlet (if available) is much safer than cat for XML
            if command -v xmlstarlet >/dev/null; then
              xmlstarlet ed -L \
                --subnode "/configuration" --type elem -n "config" \
                --subnode "/configuration/config" --type elem -n "add" -v "" \
                --subnode "/configuration/config" --type elem -n "add" -v "" \
                --subnode "/configuration/config" --type elem -n "add" -v "" \
                --subnode "/configuration/config" --type elem -n "add" -v "" \
                --subnode "/configuration" --type elem -n "packageSources" \
                --subnode "/configuration/packageSources" --type elem -n "add" -v "" \
                --set "/configuration/config/add[1]/@key" -v "globalPackagesFolder" \
                --set "/configuration/config/add[1]/@value" -v "$NUGET_CACHE_DIR/global-packages" \
                --set "/configuration/config/add[2]/@key" -v "repositoryPath" \
                --set "/configuration/config/add[2]/@value" -v "$NUGET_CACHE_DIR/global-packages" \
                --set "/configuration/config/add[3]/@key" -v "http_cache_path" \
                --set "/configuration/config/add[3]/@value" -v "$NUGET_CACHE_DIR/http-cache" \
                --set "/configuration/config/add[4]/@key" -v "defaultPushSource" \
                --set "/configuration/config/add[4]/@value" -v "https://api.nuget.org/v3/index.json" \
                --set "/configuration/packageSources/add[1]/@key" -v "nuget.org" \
                --set "/configuration/packageSources/add[1]/@value" -v "https://api.nuget.org/v3/index.json" \
                --set "/configuration/packageSources/add[1]/@protocolVersion" -v "3" \
                "$NUGET_CONFIG_DIR/NuGet.Config"
            else  # Fallback to cat if xmlstarlet is not available
              cat > "$NUGET_CONFIG_DIR/NuGet.Config" << EOF
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <config>
            <add key="globalPackagesFolder" value="$NUGET_CACHE_DIR/global-packages" />
            <add key="repositoryPath" value="$NUGET_CACHE_DIR/global-packages" />
            <add key="http_cache_path" value="$NUGET_CACHE_DIR/http-cache" />
            <add key="defaultPushSource" value="https://api.nuget.org/v3/index.json" />
          </config>
          <packageSources>
            <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
          </packageSources>
        </configuration>
        EOF
            fi
          fi
        
          echo "NuGet cache configured at $NUGET_CACHE_DIR"
        }
        
        # ==== MAINTAIN CACHE ====
        maintain_nuget_cache() {
          echo "Performing NuGet cache maintenance..."
          # Check cache size
          CACHE_SIZE=$(du -sh "$NUGET_CACHE_DIR" | cut -f1)
          echo "Current cache size: $CACHE_SIZE"
        
          # Delete temp files (safe to delete after 1 day)
          find "$NUGET_CACHE_DIR/temp" -type f -mtime +1 -delete 2>/dev/null || true
        
          # Delete old packages in http cache (aggressive, forces updates)
          find "$NUGET_CACHE_DIR/http-cache" -type f -mtime +$MAX_CACHE_AGE -delete 2>/dev/null || true
          
          # Prune global-packages if exceeding max size (using numfmt if available)
          if command -v numfmt >/dev/null 2>&1; then
            CACHE_SIZE_BYTES=$(du -s "$NUGET_CACHE_DIR" | cut -f1)
            MAX_SIZE_BYTES=$(numfmt --from=iec $NUGET_MAX_CACHE_SIZE 2>/dev/null || echo 0)  # Handle numfmt failure
        
            if [ "$CACHE_SIZE_BYTES" -gt "$MAX_SIZE_BYTES" ] && [ "$MAX_SIZE_BYTES" -gt 0 ]; then  # Check MAX_SIZE_BYTES
              echo "Cache exceeds maximum size. Pruning oldest packages..."
        
              # Find and delete oldest package *directories* (more efficient)
              find "$NUGET_CACHE_DIR/global-packages" -mindepth 2 -maxdepth 2 -type d -print0 | \
                xargs -0 -I {} bash -c 'printf "%s\t%s\n" "$(stat -c %Y "{}")" "{}"' | \
                sort -n | head -n 100 | cut -f2 | xargs -I {} sudo rm -rf "{}"  # Use sudo for removal
        
              CACHE_SIZE=$(du -sh "$NUGET_CACHE_DIR" | cut -f1)  # Recalculate
              echo "Cache size after pruning: $CACHE_SIZE"
            fi
          else
            echo "numfmt command not found, skipping size-based cache pruning"
          fi
        }
        
        # ==== SETUP BUILD ENVIRONMENT ====
        setup_build_env() {
          echo "Setting up build environment..."
          # Install .NET SDK (more robust version check and installation)
          if ! command -v dotnet &> /dev/null; then
            echo "Installing .NET SDK..."
            wget https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install -y dotnet-sdk-8.0  # Be specific about the SDK version
            rm packages-microsoft-prod.deb  # Clean up
          else
            DOTNET_VERSION=$(dotnet --version)
            echo ".NET SDK already installed: $DOTNET_VERSION"
            #  Add version check here if needed (e.g., ensure it's >= 8.0)
          fi
        
          # Create build directories
          mkdir -p "$HOME/build-agent"/{source,artifacts,logs}  # Use $HOME
        
          # Setup NuGet cache
          setup_nuget_cache
        }
        
        # ==== CLONE REPOSITORY ====
        clone_repo() {
          echo "Cloning repository..."
          cd "$HOME/build-agent/source" || exit 1 #exit if cd fails
        
          # Clean previous build (if exists)
          rm -rf ./app
        
          # Clone the repository
          git clone "$REPO_URL" ./app
        
          # Check if clone was successful
          if [ ! -d "./app" ]; then
            echo "❌ Failed to clone repository."
            exit 1
          fi
        
          cd ./app || exit 1
        
            # Check if branch exists
          if ! git branch -a | grep -q "$BRANCH_NAME"; then
            echo "❌ Branch '$BRANCH_NAME' not found in repository."
            git branch -a
            exit 1
          fi
        
          # Checkout specified branch
          git checkout "$BRANCH_NAME"
        
          echo "✅ Repository cloned and branch '$BRANCH_NAME' checked out."
        }
        
        # ==== BUILD APPLICATION WITH CACHE ====
        build_app() {
          echo "Building application using NuGet cache..."
          cd "$HOME/build-agent/source/app" || exit 1
        
          # Create log directory if it doesn't exist
          mkdir -p "$BUILD_LOG_DIR"
        
          # Restore dependencies (with caching)
          echo "Restoring dependencies (using cache)..."
          time dotnet restore --interactive:false | tee "$BUILD_LOG_DIR/restore.log"
        
          # Build the application
          echo "Building application..."
          time dotnet build --configuration Release --no-restore | tee "$BUILD_LOG_DIR/build.log"
        
           # Run tests (check for test projects more reliably)
          if find . -type f \( -name "*.Tests.csproj" -o -name "*Tests.csproj" \) -print -quit | grep -q .; then
            echo "Running tests..."
            time dotnet test --no-build --verbosity normal --configuration Release | tee "$BUILD_LOG_DIR/test.log"
          else
            echo "No test projects found, skipping tests"
          fi
        
          # Publish the application (framework-dependent, optimized)
          echo "Publishing application..."
          time dotnet publish --configuration Release --runtime linux-x64 --self-contained false -p:PublishSingleFile=false --output "$HOME/build-agent/artifacts/app" | tee "$BUILD_LOG_DIR/publish.log"
        
          # Check if build succeeded (check for published output)
          if [ ! -d "$HOME/build-agent/artifacts/app" ]; then
            echo "❌ Build failed. Check logs for details."
            exit 1
          fi
        
          # Log cache state after build
          echo "After build - NuGet cache status:"
          du -sh "$NUGET_CACHE_DIR/global-packages"
          # Maintain cache after build
          maintain_nuget_cache
          echo "✅ Build completed successfully."
        }
        
        # ==== HANDLE IDENTITY MODEL DLLS ====
        handle_identity_dlls() {
          # Check if we need identity DLLs (searching in project files, improved check)
          if find "$HOME/build-agent/source/app" -name "*.csproj" -print0 | xargs -0 grep -q "Microsoft.IdentityModel"; then
            echo "Project uses Identity Model. Setting up DLLs..."
            mkdir -p "$HOME/build-agent/identity-dlls"
            cd "$HOME/build-agent/identity-dlls" || exit 1
            # Download and extract only if needed (check for ANY dll)
            if ! find . -name "Microsoft.IdentityModel.*.dll" -print -quit | grep -q .; then
              echo "Downloading Identity Model packages..."
              # Create an array of packages to download
              PACKAGES=(
                "Microsoft.IdentityModel.Protocols/8.2.1"
                "Microsoft.IdentityModel.Logging/8.2.1"
                "Microsoft.IdentityModel.Tokens/8.2.1"
                "Microsoft.IdentityModel.JsonWebTokens/8.2.1"
                "Microsoft.IdentityModel.Protocols.OpenIdConnect/8.2.1"
                "System.IdentityModel.Tokens.Jwt/8.2.1"
              )
              # Download packages in parallel using background processes
              for pkg_spec in "${PACKAGES[@]}"; do
                pkg_name=$(echo "$pkg_spec" | cut -d/ -f1)
                pkg_version=$(echo "$pkg_spec" | cut -d/ -f2)
                pkg_short=$(echo "$pkg_name" | cut -d. -f3 | tr '[:upper:]' '[:lower:]')
        
                echo "Downloading $pkg_name v$pkg_version..."
                wget -q "https://www.nuget.org/api/v2/package/$pkg_name/$pkg_version" -O "./$pkg_short.nupkg" &
              done
        
              # Wait for all downloads to complete
              wait
        
              # Extract DLLs
              for pkg_short in protocols logging tokens jwt openidconnect systemjwt; do
                if [ -f "./$pkg_short.nupkg" ]; then
                  mkdir -p "./tmp-$pkg_short"
                  unzip -q "./$pkg_short.nupkg" -d "./tmp-$pkg_short"
                  # Copy only .dll files from the correct net8.0 folder
                  find "./tmp-$pkg_short/lib/net8.0" -name "*.dll" -exec cp {} ./ \;
                  rm -rf "./tmp-$pkg_short"
                  rm "./$pkg_short.nupkg"
                else
                  echo "Warning: Package $pkg_short was not downloaded successfully."
                fi
              done
            else
              echo "Identity DLLs already exist, reusing..."
            fi
        
            # Copy to deployment location (using sudo and more robust path handling)
            APP_PATH="/var/www/$APP_NAME"
        
            sudo mkdir -p "$APP_PATH/shared/identity-libs"
            # Use find to copy only .dll files
            find . -maxdepth 1 -name "*.dll" -print0 | sudo xargs -0 -I {} cp -v "{}" "$APP_PATH/shared/identity-libs/"
            find . -maxdepth 1 -name "*.dll" -print0 | sudo xargs -0 -I {} cp -v "{}" "$APP_PATH/current/" 2>/dev/null || true
            sudo chown -R www-data:www-data "$APP_PATH/shared/identity-libs" "$APP_PATH/current"
        
            echo "✅ Identity DLLs set up successfully."
          else
            echo "Project does not use Identity Model. Skipping DLL setup."
          fi
        }
        
        # ==== DEPLOY APPLICATION ====
        deploy_app() {
          echo "Deploying application..."
        
          # Create necessary directories
          APP_PATH="/var/www/$APP_NAME"
        
          sudo mkdir -p "$APP_PATH"/{releases,shared/logs}
        
          # Create timestamp for release
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          RELEASE_PATH="$APP_PATH/releases/$TIMESTAMP"
        
          sudo mkdir -p "$RELEASE_PATH"
        
          # Copy files to release directory (using rsync for efficiency and safety)
          sudo rsync -a --progress "$HOME/build-agent/artifacts/app/" "$RELEASE_PATH/"
        
          # Update symlink (atomic operation)
          sudo ln -sfn "$RELEASE_PATH" "$APP_PATH/current"
        
          # Set permissions
          sudo chown -R www-data:www-data "$APP_PATH"
        
            # Find main DLL (more robust, handles different project structures)
            DLL_FILE=$(find "$RELEASE_PATH" -type f -name "*.dll" | grep -v "Microsoft" | head -1)
            if [ -z "$DLL_FILE" ]; then
                echo "❌ ERROR: Cannot find main DLL file. Deployment failed."
                exit 1
            fi
            DLL_NAME=$(basename "$DLL_FILE")
            DLL_DIR=$(dirname "$DLL_FILE")
        
          echo "Found main application DLL: $DLL_NAME"
        
         # Update supervisor config (use systemctl for service management, if available)
          if command -v systemctl >/dev/null 2>&1; then
            echo "Updating systemd service configuration..."
        
            sudo bash -c "cat > /etc/systemd/system/$APP_NAME.service << EOF
        [Unit]
        Description=$APP_NAME
        After=network.target
        
        [Service]
        WorkingDirectory=$DLL_DIR
        ExecStart=dotnet $DLL_FILE
        Restart=always
        RestartSec=10  # Restart after 10 seconds if the service fails
        SyslogIdentifier=$APP_NAME
        User=www-data
        Environment=ASPNETCORE_ENVIRONMENT=Production
        Environment=ASPNETCORE_URLS=http://localhost:5000
        
        [Install]
        WantedBy=multi-user.target
        EOF"
            sudo systemctl daemon-reload
            sudo systemctl enable "$APP_NAME"
            sudo systemctl restart "$APP_NAME"
        
          else # Fallback to supervisor if systemd is not available.
             echo "Updating supervisor configuration..."
            sudo bash -c "cat > /etc/supervisor/conf.d/$APP_NAME.conf << EOF
        [program:$APP_NAME]
        command=dotnet $DLL_FILE
        directory=$DLL_DIR
        autostart=true
        autorestart=true
        stderr_logfile=/var/log/$APP_NAME/$APP_NAME.err.log
        stdout_logfile=/var/log/$APP_NAME/$APP_NAME.out.log
        environment=ASPNETCORE_ENVIRONMENT=Production,ASPNETCORE_URLS=\"http://localhost:5000\"
        user=www-data
        stopsignal=INT
        EOF"
            sudo mkdir -p "/var/log/$APP_NAME"
            sudo chown -R www-data:www-data "/var/log/$APP_NAME"
        
            sudo supervisorctl reread
            sudo supervisorctl update
            sudo supervisorctl restart "$APP_NAME"
          fi
        
          # Update Nginx config (more robust, handles existing configs better)
          NGINX_CONF="/etc/nginx/sites-available/$APP_NAME"
          if [ ! -f "$NGINX_CONF" ]; then
            echo "Creating Nginx configuration..."
            sudo bash -c "cat > $NGINX_CONF << EOF
        server {
            listen 80;
            server_name api.ksms.news;  # Use the correct domain name
        
            location / {
                proxy_pass http://localhost:5000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection keep-alive;
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_set_header X-Real-IP \$remote_addr;
        
                # Buffer settings (adjust as needed)
                proxy_buffers 16 16k;
                proxy_buffer_size 16k;
                proxy_read_timeout 300s;
                proxy_connect_timeout 300s;
            }
        }
        EOF"
          else
            echo "Nginx configuration file already exists.  Skipping creation (ensure it's correct)."
          fi
        
           # Enable site (if needed) and remove default
            if [ ! -L "/etc/nginx/sites-enabled/$APP_NAME" ]; then
                sudo ln -s "$NGINX_CONF" /etc/nginx/sites-enabled/
            fi
        
            if [ -L "/etc/nginx/sites-enabled/default" ]; then
               sudo rm -f /etc/nginx/sites-enabled/default
            fi
        
          # Check Nginx configuration
          echo "Validating Nginx configuration..."
          sudo nginx -t
        
          # Reload Nginx
          echo "Reloading Nginx..."
          sudo systemctl reload nginx
        
          # Cleanup - keep 3 latest releases (more robust)
          echo "Cleaning up old releases..."
          cd "$APP_PATH/releases" || exit 1
          ls -t | tail -n +4 | xargs -I {} sudo rm -rf "{}" 2>/dev/null || true
        
          # Clean build artifacts to save space
          echo "Cleaning build artifacts..."
          rm -rf "$HOME/build-agent/artifacts/*"
        
          echo "✅ Deployment completed successfully!"
        }
        
        # ==== MAIN EXECUTION ====
        main() {
          # Input parameters (with defaults and input validation)
          REPO_URL="${1:-https://github.com/yourusername/yourrepo.git}" # replace with your default
          BRANCH_NAME="${2:-main}"
          DEPLOY="${3:-true}"
        
          # Basic input validation
          if [ -z "$REPO_URL" ]; then
            echo "Error: Repository URL must be provided."
            exit 1
          fi
        
          echo "==== Starting VPS Build Process with NuGet Caching ===="
          echo "Repository: $REPO_URL"
          echo "Branch: $BRANCH_NAME"
          echo "Will deploy: $DEPLOY"
          echo "Using NuGet cache: $NUGET_CACHE_DIR"
        
          setup_build_env
          clone_repo
          build_app
        
          if [ "$DEPLOY" == "true" ]; then
            handle_identity_dlls
            deploy_app
            echo "==== Deployment Completed Successfully! ===="
          else
            echo "==== Build Completed Successfully (No Deployment) ===="
          fi
        
          # Print summary
          echo ""
          echo "==== Build and Deployment Summary ===="
          echo "✅ Build environment: Setup complete"
          echo "✅ Repository: Cloned successfully"
          echo "✅ Branch: $BRANCH_NAME checked out"
          echo "✅ Build: Completed"
        
          if [ "$DEPLOY" == "true" ]; then
            echo "✅ Deployment: Completed"
            echo "✅ Application URL: http://api.ksms.news" # correct URL
          else
            echo "ℹ️ Deployment: Skipped as requested"
          fi
        
          echo ""
          echo "Cache information:"
          du -sh "$NUGET_CACHE_DIR"
          echo ""
        }
        
        # Run main function with arguments
        main "$@"
        EOLSCRIPT
        chmod +x build-with-cache.sh

    - name: Copy and Execute Build Script on VPS
      run: |
        # Determine if we should deploy
        DEPLOY="false"
        if [[ "${{ github.event_name }}" == "push" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
        DEPLOY="true"
        fi
    
        # Upload script to VPS
        scp build-with-cache.sh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/build-with-cache.sh
    
        # Execute remote build on VPS with GitHub token
        ssh -o ConnectTimeout=10 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "bash ~/build-with-cache.sh 'https://x-access-token:${{ secrets.GH_TOKEN }}@github.com/Koi-Show-Management-System/ksms-BE.git' 'main' '$DEPLOY'"

    - name: Report Completion
      if: always()  # Run even if previous steps fail
      run: |
        if [ $? -eq 0 ]; then
          echo "✅ CI/CD Pipeline completed successfully!"
        else
          echo "❌ CI/CD Pipeline failed. Check the logs for details."
          exit 1  # Ensure the workflow fails if the build fails
        fi
